# Blast
##### Provides a fast scripting language for running statemachines or other decision making processes from bursted code in unity.

Scripts can be compiled at runtime from any text source and they can be store in a repository. Any script known at compiletime can also be transpiled into burst c# function pointers for optimal performance and seamless integration of fast native code and scripted segments. This takes away the complexity of seperate code paths usually used for optimal performance and lets the developer focus on other parts. This also means that the performance penalty of script can be completely mitigated if its known at compile time without changes to the code base other then autogenerated code from blast. The game could download scripts between binary updates to provide updated responses and then after releasing an updated game assembly use those same scripts with the same calling code but then backed by pure bursted code.

## SSMD
### Single Script Multiple Data

In many large scale simulations many scripts are mostly the same but with different data. BLAST can execute those with the control flow inverted, meaning that it in essence performs the SIMD equivelent of scripting languages, each operation will translate in a vector operation easily compiled to beautiful packed assembly. This can result in script running faster then native code dueue to the ways memory is forced to be and execution is performed. Usually this kind of optimization is not simply possible in real-life situations with compiled code. In SSMD mode, BLAST can handle scripts faster then native code in single execution. It shows how it becomes possible to optimize otherwise hard to optimize parts, especially if they were entered by a user in an online game were there is no control. 

### Features 

- Limited datatype support: Numerics and IDs 
- Small memory footprint 
- Code & Data seperated 
- Integrates with DOTS
- Uses BURST function pointers to connect to basic functionality in its environment. 
- Seperation of code, data and stack
- Editor/Build time functionality to convert scripts into bursted function pointers with no difference in usage to the developer but with native performance.
- SSMD mode, executes multiple script with simular controlflow but different data at once as if they were vectors
- Hybrid register/stackbased interpretor 
- Interpretation is BURST compatible.
- Unmatched performance. 

<img width="80%" alt="BLAST with BURST" src="https://user-images.githubusercontent.com/96932314/149854610-540e2ae4-2cb8-4502-8db4-b3b3ed9a4c71.PNG">

### Code Structure 

#### Variables 

Variables dont need to be defined although users might want to force usage of the ID datatype. All data starts out as a float in BLAST and either grows into vectors or gets converted/defined as an ID. For blast its assumed that float is the prefered datatype.

Currently a variable is promoted to an id by use of a function: `a_as_id = ID64;  a_as_id = ID64(value); `, functions in blast may convert datatypes and allow us to cleanly configure datatypes used outside the interpretor. Leveraging this we could release float or ID only interpretors for maximum speed in the future. 

#### Statements 

A statement is: 
- a collection of operations assigned to a variable terminated with a `;`: `a = 1 * 3 + maxa((1 2 3), (5 6 7));` 
- a procedure call: 'procedure_identifier(12);' 

Control flows may nest statements statements:

- If Then Else:  `if ( a | b ) then ( c = 1; ) else ( c = 2; );`
- While loop: `while( i < 100) ( i = i + 1;);`
- For loop: `for( i = 0; i < 100; i = i + 1) ( a = a / 4; );` 
- Switch: `switch (a) (case 3: ( a = 2; ) default: ( a = 3;));`

_The intitial language version will demand use of compounds in all situations. Later version may relax on this constraint. _

#### Compounds 

Everything between  `(` and `)` is called a compound, a compound may have several interpretations: 

- A list of statements: `( a = 1; b = 2; c = a * b; );` 
- Structuring of sequences: `a = a + (a | b);`
- A list of parameters: `(a, b, c);`
- A vector definition: `a = (1 2 3 4);`

## Data types 

There is limited datatype support: 

```Unknown: determined at runtime 

Numeric: 1.0 etc

ID: Integers

Vectors:  ID(n) and NUMERIC(n) up until n = 16, 
          id(3)       => (1 2 3)
          NUMERIC(3)  =>  (1.2 2.3 2.45)
```
### NUMERIC  
The default datatype is the numeric, unless otherwise set the compiler assumes the numeric datatype which is a 32 bit float. 

### ID
The ID datatype is used to represent an ID, because numerics will not round correctly on indices with more then 6/7 digits the ID is used to correct index large lists.

### Vectors
Vectors may be defined based on all supported datatypes and functions, constant and functions may be mixed but the number of dataelements must be equal for each element defined in the vector. 



1> Defines a, a vector of 2 constants and 1 pop operation popping 1 numeric or id:
` a = (1 pop 2); `

2> Defines b, a vector of 2 constants of size 3 and a pop3:
` b = ((1 2 3) (pop pop pop) (1 2 3)); ` 

#### Vector mapping assumptions
Vectors map automatically to matrices of the same element size: n(9) => m(3x3), n(12) => m(3x4) | m(4x3) etc. 

## Tokens

Arithmetic operators:   `+ - / *`

Boolean operators:      `& | ^ !` 

Boolean evaluators:     `< > <= >= = ! !=`

Ternary operator:       `[condition] ? [true] : [false]` 

Assignment:             `=`

Enclosures:             `( )`

Statement terminator:   `;` 

Value seperator:        `,` 

Decimal seperator:      `.` 

Indexer                 `.` 

IndexOpen               `[`

IndexClose              `]`

Identifier: 	          `[a..z][0..9|a..z]*[.|[][a..z][0..9|a..z]*[]]`

Control Flow:           `if then else` 
                        `while for ` 
                        `switch case default`

## Code Structure

The # is used to define constants, input and output(s) and validations. Any sequence not matching `#[define/input/output/validate]` is considered a comment. 

- A `#[definition]` must appear at the start of the line 
- Defines and inputs must appear in the code BEFORE any other code 
- A comment can be started at any point in the line

### Use of #
``` 
#define   variable  [value]
#input    variable  [offset] [bytesize]
#output   variable  [offset] [bytesize]
#validate variable  [value] 
``` 

All other text that starts with # is a comment and may start at any point of a line, also after `#[definition]`:

``` 
#input    variable  [offset] [bytesize]    # comment 123
``` 
