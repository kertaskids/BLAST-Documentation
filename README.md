# Blast
##### Provides a fast scripting language for running statemachines or other decision making processes from bursted code in unity.

Scripts can be compiled at runtime from any text source and they can be store in a repository. Any script known at compiletime can also be transpiled into burst c# function pointers for optimal performance and seamless integration of fast native code and scripted segments. This takes away the complexity of seperate code paths usually used for optimal performance and lets the developer focus on other parts. This also means that the performance penalty of script can be completely mitigated if its known at compile time without changes to the code base other then autogenerated code from blast. The game could download scripts between binary updates to provide updated responses and then after releasing an updated game assembly use those same scripts with the same calling code but then backed by pure bursted code.

## SSMD
### Single Script Multiple Data

In many large scale simulations many scripts are mostly the same but with different data. BLAST can execute those with the control flow inverted, meaning that it in essence performs the SIMD equivelent of scripting languages, each operation will translate in a vector operation easily compiled to beautiful packed assembly. This can result in script running faster then native code dueue to the ways memory is forced to be and execution is performed. Usually this kind of optimization is not simply possible in real-life situations with compiled code. In SSMD mode, BLAST can handle 5 script expression each nano-second, this is offcoarse averaged over the bulk but it shows how it becomes possible to optimize otherwise hard to optimize parts, especially if they were entered by a user in an online game were there is no control. 

### Features 

- Limited datatype support: Numerics and IDs 
- Small memory footprint 
- Code & Data seperated 
- Integrates with DOTS
- Uses BURST function pointers to connect to basic functionality in its environment. 
- Seperation of code, data and stack
- Editor/Build time functionality to convert scripts into bursted function pointers with no difference in usage to the developer but with native performance.
- SSMD mode, executes multiple script with simular controlflow but different data at once as if they were vectors
- Hybrid register/stackbased interpretor 
- Unmatched performance. 
- Interpretation is BURST compatible.

## Usage


## Data types 

There is limited datatype support: 

```Unknown: determined at runtime 

Numeric: 1.0 etc

ID: Integers

Vectors:  ID(n) and NUMERIC(n) up until n = 16, 
          id(3)       => (1 2 3)
          NUMERIC(3)  =>  (1.2 2.3 2.45)
```
### NUMERIC  
The default datatype is the numeric, unless otherwise set the compiler assumes the numeric datatype which is a 32 bit float. 

### ID
The ID datatype is used to represent an ID, because numerics will not round correctly on indices with more then 6/7 digits the ID is used to correct index large lists.

### Vectors
Vectors may be defined based on all supported datatypes and functions, constant and functions may be mixed but the number of dataelements must be equal for each element defined in the vector. 

1> Defines a, a vector of 2 constants and 1 pop operation popping 1 numeric or id:
` a = (1 pop 2); `


2> Defines b, a vector of 2 constants of size 3 and a pop3:
` b = ((1 2 3) (pop pop pop) (1 2 3)); ` 

#### Vector mapping assumptions
Vectors map automatically to matrices of the same element size: n(9) => m(3x3), n(12) => m(3x4) | m(4x3) etc. 

## Tokens

Arithmetic operators:   `+ - / *`

Boolean operators:      `& | ^ !` 

Boolean evaluators:     `< > <= >= = ! !=`

Ternary operator:       `[condition] ? [true] : [false]` 

Assignment:             `=`

Enclosures:             `( )`

Statement terminator:   `;` 

Value seperator:        `,` 

Decimal seperator:      `.` 

Indexer                 `.` 

IndexOpen               `[`

IndexClose              `]`

Identifier: 	          `[a..z][0..9|a..z]*[.|[][a..z][0..9|a..z]*[]]`

Control Flow:           `if then else` 
                        `while for ` 
                        `switch case default`

## Code Structure

The # is used to define constants, input and output(s) and validations. Any sequence not matching `#[define/input/output/validate]` is considered a comment. 

- A `#[definition]` must appear at the start of the line 
- Defines and inputs must appear in the code BEFORE any other code 
- A comment can be started at any point in the line

### Use of #
``` 
#define   variable  [value]
#input    variable  [offset] [bytesize]
#output   variable  [offset] [bytesize]
#validate variable  [value] 
``` 

All other text that starts with # is a comment and may start at any point of a line, also after `#[definition]`:

``` 
#input    variable  [offset] [bytesize]    # comment 123
``` 
